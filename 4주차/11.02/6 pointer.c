#include <stdio.h>

void swap(int a, int b);

void swap_addr(int *a, int *b);

changeArray(int *ptr);

int main(void)
{
    // printf("Hello World\n");

    // ##########친구들의 주소

    // 포인터

    // [철수] : 101호 -> 메모리 공간의 주소(6422036)
    // [영희] : 201호 -> 메모리 공간의 주소(6422040)
    // [민수] : 301호 -> 메모리 공간의 주소(6422036)
    // 주소는 정확히는 '메모리의 주소값'임

    // 각자 문 앞에 '암호'가 걸려 있음
    // 암호는 '메모리에 저장된 값(value)'임
    // int Cs = 1;
    // 철수의 암호 : 1
    // int Yh = 2;
    // 영희의 암호 : 2
    // int Ms = 3;
    // 민수의 암호 : 3

    // printf("(일반변수를 이용해서 주소와 값을 출력)\n");

    // printf("철수네 주소[변수의 메모리 주소] : %d, 암호[변수의 값] : %d\n", &Cs, Cs);
    // printf("영희네 주소 : %d, 암호 : %d\n", &Yh, Yh);
    // printf("민수네 주소 : %d, 암호 : %d\n\n", &Ms, Ms);

    // ############미션맨(포인터)의 등장

    // 미션맨 !

    // printf("\n ... 미션맨이 미션 수행하는 중 ... \n\n");
    // printf("(포인터변수를 이용해서 주소와 값을 출력)\n");

    // 미션맨의 첫 번째 미션 : 아파트의 각 집에 방문하여 문에 적힌 암호 확인

    // int * XMan;
    // 포인터 변수 선언

    // XMan = &Cs;
    // '포인터 변수'는 '특정 변수의 메모리 주소'를 저장함
    // printf("미션맨이 방문하는 곳 주소[변수의 메모리 주소] : %d, 암호[변수의 값] : %d\n", XMan, *XMan);

    // XMan = &Yh;
    // printf("미션맨이 방문하는 곳 주소 : %d, 암호 : %d\n", XMan, *XMan);

    // XMan = &Ms;
    // printf("미션맨이 방문하는 곳 주소 : %d, 암호 : %d\n\n", XMan, *XMan);

    // 미션맨의 두 번째 미션 : 각 암호에 3을 곱해라

    // printf("(포인터변수를 이용해서 값에 접근)\n");

    // XMan = &Cs;
    // *XMan = *XMan * 3;
    // '포인터변수'도 '*포인터변수'를 이용해서 값(value)에 접근가능

    // printf("미션맨이 암호를 바꾼 곳 주소[변수의 메모리 주소] : %d, 암호[변수의 값] : %d\n", XMan, *XMan);

    // XMan = &Yh;
    // *XMan = *XMan * 3;
    // printf("미션맨이 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", XMan, *XMan);

    // XMan = &Ms;
    // *XMan = *XMan * 3;
    // printf("미션맨이 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", XMan, *XMan);

    // ############스파이(또다른 포인터)의 등장
    // 스파이
    // 스파이의 미션 : 미션맨이 바꾼 암호에서 2를 빼라!

    // int * Spy = XMan;
    // 스파이(Spy)
    //              =>   누군가의 아파트 주소(특정 변수의 메모리 주소)
    // 미션맨(XMan)

    // 현재 두 개의 서로 다른 '포인터 변수'(Spy와 XMan)가
    // 서로 '같은 특정 변수의 메모리 주소'를 가리키고 있음

    // printf("\n ... 스파이가 미션 수행하는 중 ... \n\n");
    // printf("(포인터변수를 이용해서 값에 접근)\n");

    // Spy = &Cs;
    // '포인터 변수'에 '특정 변수의 주소값' 저장

    // *Spy = *Spy - 2;
    // '*포인터변수'를 이용해서 '특정변수의 값(value)'에 접근
    // 'Cs = Cs - 2;'와 동일한 문장임

    // printf("스파이가 방문하는 곳 주소[변수의 메모리 주소] : %d, 암호[변수의 값] : %d\n", Spy, *Spy);

    // Spy = &Yh;
    // *Spy = *Spy - 2;
    // printf("스파이가 방문하는 곳 주소 : %d, 암호 : %d\n", Spy, *Spy);

    // Spy = &Ms;
    // *Spy = *Spy - 2;
    // printf("스파이가 방문하는 곳 주소 : %d, 암호 : %d\n", Spy, *Spy);

    // printf("\n ... 철수 영희 민수는 집에 오고서는 바뀐 암호를 보고 깜놀 ...\n\n");
    // printf("(일반변수의 값[value]도 변경됐는지 확인)\n");
    // '포인터변수'가 '*포인터변수'를 이용해서 '특정변수의 값(value)'에 접근했는데
    // '일반변수'를 출력해서 실제로 '특정변수의 값(value)'이 변경이 됐는지 확인하기

    // printf("철수네 주소[변수의 메모리 주소] : %d, 암호[변수의 값] : %d\n", &Cs, Cs);
    // printf("영희네 주소 : %d, 암호 : %d\n", &Yh, Yh);
    // printf("민수네 주소 : %d, 암호 : %d\n\n", &Ms, Ms);

    // 참고로.. 미션맨이 사는 곳의 주소는 '&XMan'으로 확인 가능
    // ('포인터변수'의 메모리주소도 '&포인터변수'로 확인 가능)

    // printf("\n(포인터변수의 주소값을 확인)\n");

    // printf("미션맨의 주소 : %d\n", &XMan);
    // printf("스파이의 주소 : %d\n", &Spy);

    // #############배열과 포인터의 관계

    // 배열 ?
    // 배열은 포인터와 아주 가깝게 연관이 있음

    // int arr[3] = {5, 10, 15};
    // int * ptr = arr;
    // '포인터변수'(ptr)에는 항상 '특정변수의 주소값'(arr) 저장함
    // arr == (arr + 0) == &arr[0] : 배열 arr의 첫번째 주소값(arr[0]의 주소값)

    // for(int i = 0; i < 3; i++) {
    //     printf("배열 arr[%d]의 값 : %d\n", i, arr[i]);
    // }

    // for(int i = 0; i < 3; i++) {
    //     printf("포인터 ptr[%d]의 값 : %d\n", i, ptr[i]);
    // }
    // '포인터변수'는 '포인터변수[i]'를 이용해서 '포인터변수'에 저장된
    // '특정변수의 주소값'에서 i만큼 거리가 있는 '값'(value)에 접근이 가능함
    // (cf. '포인터변수'는 '*포인터변수'로 '특정변수의 값'(value)에 접근이 가능함)

    // printf("\n");

    // ptr[0] = 100;
    // ptr[1] = 200;
    // ptr[2] = 300;
    // '포인터변수[i]'를 이용해서 '포인터변수'에 저장된
    // '특정변수의 주소값에서 i만큼 거리가 있는 값'(value)에 접근하면
    // 실제 '배열의 값'(value)이 변경되는 것을 출력으로 확인 가능

    // for(int i = 0; i < 3; i++) {
    //     // printf("배열 arr[%d]의 값 : %d\n", i, arr[i]);
    //     printf("배열 arr[%d]의 값 : %d\n", i, *(arr + i));
    // }

    // for(int i = 0; i < 3; i++) {
    //     // printf("포인터 ptr[%d]의 값 : %d\n", i, ptr[i]);
    //     printf("포인터 ptr[%d]의 값 : %d\n", i, *(ptr + i));
    // }

    // *(arr + i) == arr[i]
    // 둘은 서로 똑같은 표현임

    // arr이 결국 '특정 주소값[arr 배열의 첫번째 값의 주소]'을 의미하기 때문에
    // '*(arr + i)'은 '*(특정 주소값+i)'라서 특정 주소값에서 i만큼 떨어진 주소값을 가지는
    // 변수의 값(value)을 의미함
    // 'arr[i]'는 해당 배열(arr)에서 i번째에 해당되는 값(value)을 의미함
    // 결과적으로 '*(arr + i)'과 'arr[i]'은 같은 의미임

    // printf("\n");

    // arr == &arr[0] : arr 배열의 첫번째 값의 주소
    // printf("arr 자체의 값 : %d\n", arr);
    // printf("arr[0]의 주소 : %d\n", &arr[0]);

    // printf("\n");

    // printf("arr 자체의 값(주소값)의 실제 값(value) : %d\n", *arr);
    // *arr == *(arr + 0)

    // printf("arr[0] 주소(&arr[0])의 실제 값 : %d\n", *&arr[0]);

    // printf("\n");

    // *& 는 아무것도 없는 것과 같다
    // & 는 주소이며 * 는 그 주소의 값(value)이기 때문에
    // *& 는 서로 상쇄됨
    // printf("arr[0] 주소의 실제 값 : %d\n", *&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&arr[0]);
    // printf("arr[0] 주소의 실제 값 : %d\n", arr[0]);

    // ################### Swap

    // SWAP
    // int a = 10;
    // int b = 20;

    // 값에 의한 복사 (Call by Value) -> 값만 복사한다는 의미
    // swap() 함수에서는 a와 b의 값(value)만 매개변수로 주었을 뿐임
    // (매개변수로 a와 b 자체를 던져준 것은 아님)
    // (swap()함수에 있는 변수 a, b와 메인함수에 있는 변수 a, b는 서로 다른 메모리 주소를
    // 가진 다른 변수임)

    // printf("-----Call by Value-----\n");

    // printf("a의 주소 : %d\n", &a);
    // printf("b의 주소 : %d\n", &b);

    // a와 b의 값을 바꾼다
    // printf("Swap 함수 전 => a : %d, b : %d\n\n", a, b);
    // swap(a, b);
    // printf("Swap 함수 후 => a : %d, b : %d\n", a, b);
    // 분명히 swap() 함수에서는 a와 b가 바뀌었는데 메인함수에서는 바뀌지 않음

    // printf("\n");

    // 참조에 의한 호출 (Call by Reference) -> 주소값을 복사한다는 의미
    // 주소값을 넘기면? 메모리 공간에 있는 주소값 자체를 넘기면 -> 철수네(Cs)처럼
    // (매개변수로 a와 b 자체를 던져줌)

    // printf("-----Call by Reference-----\n");

    // printf("a의 주소 : %d\n", &a);
    // printf("b의 주소 : %d\n", &b);

    // printf("(주소값 전달) Swap 함수 전 => a : %d, b : %d\n\n", a, b);

    // swap_addr(&a, &b);
    // 매개변수로 a와 b의 주소들을 보내줌

    // printf("(주소값 전달) Swap 함수 후 => a : %d, b : %d\n", a, b);

    // ###############포인터로 배열 값 변경하기

    // 배열일 때는, arr2 -> 주소값
    // ('arr2'는 'arr2 배열의 첫번째 값의 주소' : arr2 == &arr2[0])
    int arr2[3] = {10, 20, 30};

    // arr2[3]을 50으로 바꾸고 싶음
    // changeArray(arr2);
    changeArray(&arr2[0]);
    // 함수 내에서 배열의 '값'(value)을 바꾸고 메인함수에 반영하고 싶다면
    // Call by Reference로 '주소값'(arr2나 &arr2[0])을 매개변수로 보내서
    // '포인터변수'로 받으면 됨
    // (실제로 함수를 통해서 arr2[3]을 50으로 바뀜)

    for (int i = 0; i < 3; i++)
    {
        printf("%d\n", arr2[i]);
    }

    // scanf_s()에서 &num과 같이 &를 사용하는 이유는 무엇일까?

    return 0;
}

void swap(int a, int b)
{

    printf("(Swap 함수 내) a의 주소 : %d\n", &a);
    printf("(Swap 함수 내) b의 주소 : %d\n", &b);

    int temp = a;
    // 기존 a의 값을 temp로 저장

    a = b;
    // 기존 b의 값을 a에 저장

    b = temp;
    // 기존 a의 값을 b에 저장

    printf("Swap 함수 내 => a : %d, b : %d\n\n", a, b);
    // 분명히 swap() 함수에서는 a와 b가 바뀌었는데 메인함수에서는 바뀌지 않음
}

void swap_addr(int *a, int *b)
{
    // 매개변수로 '주소값'을 받기 위해서는 '포인터변수'가 필요함

    printf("(Swap_addr 함수 내) a의 주소 : %d\n", a);
    printf("(Swap_addr 함수 내) b의 주소 : %d\n", b);
    // 매개변수를 '포인터변수'로 '주소값'을 받았기 때문에
    // a와 b가 각각 주소값을 지니는 '포인터변수'임

    int temp = *a;
    *a = *b;
    *b = temp;
    // a와 b는 주소값을 지니는 '포인터변수'이기 때문에
    // a와 b의 값(value)을 swap하기 위해서는 '*포인터변수'를 사용해야
    // 값(value)에 접근할 수 있음

    printf("(주소값 전달) Swap 함수 내 => a : %d, b : %d\n\n", *a, *b);
    // 값에 접근하기 위해서 *a와 *b를 사용함
    // swap_addr() 함수에서 a와 b가 바뀐대로 메인함수에서도 바뀜
}

changeArray(int *ptr)
{
    // 매개변수로 '주소값'(arr2)를 보냈기 때문에 '포인터변수'(ptr)로 받음

    ptr[2] = 50;
    // ptr[i]를 이용해서 '값'(value)에 접근함
}