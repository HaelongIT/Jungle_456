rbtree_erase(rb트리, 삭제할 노드)
	실제 삭제되는 노드
	삭제되는 노드의 부모노드
	삭제되는 노드의 대체노드
	is_remove_black, is_remove_left

	만약 자식이 둘이라면
		실제 삭제되는 노드(후계노드) = get_next_node(rb트리, 삭제할 노드)
		삭제되는 노드의 대체노드는 오른쪽노드가 대체
		\가장 왼쪽노드였어서 오른쪽 노드만 있음(또는 nil이거나)\
		삭제될 노드의 key는 대체노드의 key로 변경
		\대체노드 삭제 하고 그 자리에 대체노드의 대체가 들어와야 하는데 그 부분은 없음\

	자식이 없거나 하나인 경우
		실제 삭제되는 노드는 삭제할 노드
		삭제되는 노드의 대체노드는 자식이 있으면 자식노드로 없으면 nil노드로 대체
		\실제 삭제할 노드 삭제하는 부분, 대체 노드가 그 자리로 들어가는 부분이 없음\

	is_remove_black에 실제 삭제되는 노드의 부모를 저장
	is_remove_left에 부모의 왼쪽 자식인지 저장

	만약 실제 삭제할 노드가 루트노드라면
		루트노드를 대체노드로 변경
		루트노드의 색을 블랙으로 변경
		삭제할 노드의 메모리를 풀어줌
		종료

	is_remove_black은 지워질 노드의 색 저장
	\위에서 free(remove)로 메모리 할당 해제했는데 색을 저장할 수가 있나?\	\위에서는 삭제할 노드가 루트노드 일때만 이고 이건 나머지 경우에\
	is_remove_left는 지워질 노드의 부모의 왼쪽 자식인지 확인
	
	만약 삭제될 놈이 왼쪽 자식이였으면
		삭제할 노드 부모의 왼쪽은 대체될 노드로 변경
	오른쪽 자식이였으면
		삭제할 노드 부모의 오른쪽은 대체될 노드로 변경

	대체될 노드의 부모는 삭제될 노드의 부모
	삭제할 노드의 메모리를 풀어줌

	만약 삭제할 노드의 색이 블랙이였으면
		rbtree_erase_fixup(t, remove_parent, is_remove_left);
		\재조정을 위한 함수의 매개변수로 왜 remove_parent가 들어갈까? (왜 삭제되는 노드인 p가 아니라 그 부모가 들어갈까)\
	리턴