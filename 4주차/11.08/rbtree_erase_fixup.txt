rbtree_erase_fixup(rb트리, 삭제된 노드의 부모, is_left)
	엑스트라 블랙(노드)은 is_left가 참이면 부모의 왼쪽자식이고 거짓이면 오른쪽 자식이다
	\아마 엑스트라 블랙은 엑스트라 블랙을 노드에 붙이는 개념이 아니고 엑스트라 블랙이 붙은 노드 자체를 엑스트라 블랙이라고 하는듯\

	만약 엑스트라블랙이 레드-앤드-블랙이면
	\쉽게 레드-앤드-블랙으로 해결되는 경우\
		엑스트라 블랙은 블랙노드가 된다
		리턴

	형제노드는 is_left가 참이면 부모노드의 오른쪽 자식이고 거짓이면 왼쪽 자식이다
	\왜냐하면 extra_black의 반대가 형제노드니까\
	형제노드의 왼쪽노드를 저장
	형제노드의 오른쪽노드를 저장

	만약 형제노드의 색이 레드라면
	\케이스1\
		만약 엑스트라 블랙이 왼쪽이면
			왼쪽으로 돌린다
			\아마 회전은 두개중 아래쪽을 매개변수로 줘서 돌리는듯\
		만약 엑스트라 블랙이 오른쪽이면
			오른쪽으로 돌린다
		색상 바꾸고
		rbtree_erase_fixup 다시 해서 어떤 case4/3/2 중에 확인
		리턴

	near는 형제 자식중 가까운 노드
	distant는 형제 자식중 먼 노드

	만약 엑스트라 블랙이 왼쪽이면서 동시에 가까운 형제자식이 레드면서 동시에 먼 형제자식이 블랙일 경우
	\케이스3\
		오른쪽으로 돌리고
		색상 바꾸고
		rbtree_erase_fixup 다시 해서 어떤 case인지 확인	
		\아마도 케이스4가 될 것\
		리턴

	만약 엑스트라 블랙이 왼쪽이면서 동시에 먼 형제자식이 레드인 경우
		\케이스4\
		왼쪽으로 돌리고
		색상 바꾸기
		먼 형제자식 색상은 블랙으로 변경
		\근데 왜 부모의 색상은 블랙으로 안바꾸지?\
		리턴

	형제의 가까운 자식이 red 이면서 동시에 형제의 먼 자식은 블랙이 경우
	\형제가 레드는 걸러져서 형제는 블랙임\
	\케이스3\
		왼쪽으로 돌리고
		색상 바꾸고
		rbtree_erase_fixup 다시 해서 어떤 case인지 확인
		리턴
	
	만약 먼형제가 레드면
	\형제는 블랙\
	\케이스4\
		오른쪽으로 회전
		색상 바꾸고
		형제의 먼 자식은 검은색
		\근데 왜 부모의 색상은 블랙으로 안바꾸지?\
		리턴

	\마지막으로 다 걸러지고 남은 케이스 하나\
	\케이스2\
	\형제가 블랙, 형제 자식이 둘다 블랙\
	형제 색은 빨간색
	\엑스트라블랙은 그렇다고 쳐도, 왜 부모노드에는 별다른 변화가 있다는 부분이 빠져있지?\	\아마 if (parent != t->root) 부분인듯\

	만약 부모가 루트가 아니면
		rbtree_erase_fixup(t, parent->parent, parent->parent->left == parent);
		\부모가 루트면 이미 black이니까 red로 바꿔도 다시 black으로 바꿔야 해서 아무것도 안해줘도 되는 상황임\
		\즉 부모가 루트가 아닐 때는 자식과 부모의 색상을 바꿨을 때 부모로 타고올라가서 재조정 확인 해줘야함\